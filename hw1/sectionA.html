<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - lights - point lights</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background-color: #000;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				color: #ffffff;
				padding: 5px;
				font-family: Monospace;
				font-size: 13px;
				text-align: center;
			}

			a {
				color: #ff0080;
				text-decoration: none;
			}

			a:hover {
				color: #0080ff;
			}
		</style>
	</head>
	<body>

		<div id="container"></div>
		<div id="info">
			<a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> - point lights WebGL demo.<br />
			Walt Disney head by <a href="http://davidoreilly.com/post/18087489343/disneyhead" target="_blank" rel="noopener">David OReilly</a>
		</div>

		<script src="js/three.js"></script>

		<script src="js/loaders/BinaryLoader.js"></script>

        <script id="vertexShader" type="x-shader/x-vertex">

	//Three.js gives us these automatically when a perspective camera is bound to the renderer
	uniform mat4 modelMatrix;
	uniform mat4 viewMatrix;
      	uniform mat4 projectionMatrix;

	//Three.js geometry creates these for us (and also texture coords, which we aren't using here)
     	attribute vec3 position;
	attribute vec3 normal;

	//We are explicitly passing these in
      	uniform vec3 light1_pos;
      	uniform vec3 light2_pos;

	varying vec3 N, L1, L2, V;

	void main() {

        	//get the vertex position in CAMERA coordinates
        	vec4 position = viewMatrix * modelMatrix * vec4(position, 1.0);

        	//use xyz vals to calculate vectors between vertex, light, and camera
        	vec3 P = position.xyz;
    
        	//get the normalized vertex normal in CAMERA coordinates
        	N = vec3(normalize(viewMatrix * modelMatrix * vec4(normal.xyz, 0.0)  ).xyz) ;
    
        	//the lights positions are defined in WORLD coordinates, we want to put them in CAMERA coordinates too
        	vec4 L1_cam = viewMatrix * vec4(light1_pos, 1.0);
        	vec4 L2_cam = viewMatrix * vec4(light2_pos, 1.0);
    
        	//get the normalized vectors from each light position to the vertex positions
        	L1 = vec3(normalize(L1_cam - position).xyz);
        	L2 = vec3(normalize(L2_cam - position).xyz);
    
    
        	//reverse direction of position vector to get view vector from vertex to camera
        	V = normalize(-P);
    
    
        	//of course, we always have to output our vertices in clip coords by multiplying through a projection matrix.
        	gl_Position = projectionMatrix * position; 
     	 }

		</script>
        
		<script>

			var camera, scene, renderer,
			particle1, particle2,
			light1, light2, light3, light4,
			object, loader;
            
            var vs = document.getElementById( 'vertexShader' ).textContent;

			var clock = new THREE.Clock();

			init();
			animate();

			function init() {

				var container = document.getElementById( 'container' );

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.z = 100;

                texture = new THREE.TextureLoader().load( "textures/drag.jpg" );
                
				scene = new THREE.Scene();

				loader = new THREE.BinaryLoader();

				var callback = function( geometry ) {

					object = new THREE.Mesh( geometry, new THREE.MeshPhongMaterial( { color: 0x555555, specular: 0x111111, shininess: 50 }  )  );
					object.scale.x = object.scale.y = object.scale.z = 0.80;
					scene.add( object );

				};

				loader.load( "obj/walt/WaltHead_bin.js", callback );

				var sphere = new THREE.SphereGeometry( 0.5, 16, 8 );
                
                // Create a geometry
                // 	Create a box (cube) of 10 width, length, and height
                geometry = new THREE.BoxGeometry( 10, 10, 10 );
                // Create a MeshBasicMaterial with a loaded texture
                material = new THREE.MeshBasicMaterial( { map: texture} );
                
                // Combine the geometry and material into a mesh
                mesh = new THREE.Mesh( geometry, material );
                // Add the mesh to the scene
                scene.add( mesh );

				light1 = new THREE.PointLight( 0xff0040, 2, 50 );
				light1.add( new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color: 0xff0040 } ) ) );
				scene.add( light1 );

				light2 = new THREE.PointLight( 0x0040ff, 2, 50 );
				light2.add( new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color: 0x0040ff } ) ) );
				scene.add( light2 );

				light3 = new THREE.PointLight( 0x80ff80, 2, 50 );
				light3.add( new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color: 0x80ff80 } ) ) );
				scene.add( light3 );

				light4 = new THREE.PointLight( 0xffaa00, 2, 50 );
				light4.add( new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( { color: 0xffaa00 } ) ) );
				scene.add( light4 );

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				//

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();

			}

			function render() {

				var time = Date.now() * 0.0005;
				var delta = clock.getDelta();

				if( object ) object.rotation.y -= 0.5 * delta;

				light1.position.x = Math.sin( time * 0.7 ) * 30;
				light1.position.y = Math.cos( time * 0.5 ) * 40;
				light1.position.z = Math.cos( time * 0.3 ) * 30;

				light2.position.x = Math.cos( time * 0.3 ) * 30;
				light2.position.y = Math.sin( time * 0.5 ) * 40;
				light2.position.z = Math.sin( time * 0.7 ) * 30;

				light3.position.x = Math.sin( time * 0.7 ) * 30;
				light3.position.y = Math.cos( time * 0.3 ) * 40;
				light3.position.z = Math.sin( time * 0.5 ) * 30;

				light4.position.x = Math.sin( time * 0.3 ) * 30;
				light4.position.y = Math.cos( time * 0.7 ) * 40;
				light4.position.z = Math.sin( time * 0.5 ) * 30;
                
                mesh.position.x = Math.sin( time * 0.3 ) * 30;
				mesh.position.y = Math.cos( time * 0.7 ) * 40;
				mesh.position.z = Math.sin( time * 0.5 ) * 30;

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>