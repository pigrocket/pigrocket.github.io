<!DOCTYPE html>
<html lang="en">
	<head>
		<title>HW3 - Part B - SDF Scene</title>
		<meta charset="utf-8">
		<style>
			body {
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>
<body>

<div id="container"></div>

<script src="js/three.js"></script>
<script src="./js/dat.gui.min.js"></script>


<script id="vshader" type="x-shader/x-vertex">
    precision mediump float;
    uniform float time;
    varying vec3 fPosition;
    void main() {
        fPosition = position;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
</script>

<script id="fshader" type="x-shader/x-fragment">

//http://barradeau.com/blog/?p=575

precision mediump float;

uniform float time;

uniform vec2 resolution;
 
//the signed distance field function
//used in the ray march loop
float sphereSDF(vec3 pos) {
    //a sphere of radius 1.
    return length( pos ) - 1.;
}

float cubeSDF(vec3 pos){
    vec3 d = abs(pos) - vec3(.7, .7, .7);
    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}

float prismSDF(vec3 pos){
    vec3 q = abs(pos);
    vec2 h = vec2(1.0, 1.0);
    return max(q.z-h.y,max(q.x*0.866+pos.y*0.5,-pos.y)-h.x*0.5);
}

float unite( float a, float b){return min(a, b);}
float subtract( float a, float b ){ return max(-a, b); }
float intersect( float a, float b ){ return max(a, b); }

float sceneSDF(vec3 pos, float tim) {
    float sphere = sphereSDF(pos + sin(tim));
    float cube = cubeSDF(pos);
    float change = intersect(sphere, cube);
    float prisms = unite(unite(prismSDF(pos-1.0),prismSDF(pos + 1.0)), prismSDF(pos + 2.0));
    return unite(change, prisms);
}
 
void main( void ) {
 
//1 : retrieve the fragment's coordinates
	vec2 uv = ( gl_FragCoord.xy / resolution.xy ) * 2.0 - 1.0;
	//preserve aspect ratio
	uv.x *= resolution.x / resolution.y;
 
 
//2 : camera position and ray direction
	vec3 pos = vec3( 0.,0.,-3.);
	vec3 dir = normalize( vec3( uv, 1. ) );
 
 
//3 : ray march loop
    //ip will store where the ray hits the surface
	vec3 ip;
 
	//variable step size
	float t = 0.0;
	for( int i = 0; i < 32; i++) {
 
        //update position along path
        ip = pos + dir * t;
 
        //gets the shortest distance to the scene
		float temp = sceneSDF( ip, time);
 
        //break the loop if the distance was too small
        //this means that we are close enough to the surface
		if( temp < 0.01 ) break;
 
		//increment the step along the ray path
		t += temp;
 
	}
 
//4 : apply color to this fragment
    //we use the result position as the color
	gl_FragColor = vec4( ip, 1.0);
 
}
</script>

<script>
	const WIDTH = window.innerWidth;
	const HEIGHT = window.innerHeight;
	var vshader = document.getElementById( 'vshader' ).textContent;
	var fshader = document.getElementById( 'fshader' ).textContent;
	// 0. Create a renderer
	var renderer = new THREE.WebGLRenderer();
	renderer.setSize(WIDTH, HEIGHT);
	document.body.appendChild(renderer.domElement)
	// 1. Create a Scene
	var scene = new THREE.Scene();
	// 1.1 Create a camera
	var camera = new THREE.OrthographicCamera(WIDTH/-2, WIDTH/2, HEIGHT/2, HEIGHT/-2, 1, 1000);
	camera.position.z = 5;
	// //2. Create meshes
	var geometry = new THREE.PlaneGeometry(WIDTH, HEIGHT);
	var uniforms = {
		time: {type: 'f', value: 0.0},
		resolution: {type: 'v2', value: new THREE.Vector2(WIDTH, HEIGHT)}
	}
	var material = new THREE.ShaderMaterial({
		uniforms: uniforms,
		vertexShader: vshader,
		fragmentShader: fshader,
	});
	var fullScreenQuad = new THREE.Mesh(geometry, material);
	scene.add(fullScreenQuad);
	
	function animate() {
		requestAnimationFrame( animate );
		fullScreenQuad.material.uniforms.time.value += 0.01;
		renderer.render( scene, camera );
	}
	animate();
</script>